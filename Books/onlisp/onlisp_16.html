<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="ja">
<!-- Created on November, 13  2007 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=euc-jp">
<META NAME="keywords" CONTENT="meadow,mule,emacs,lisp,elisp,gnus,setting,unix,cygwin">
<META http-equiv="Content-Script-Type" content="text/javascript">
<META NAME="description" CONTENT="On Lisp Html version">
<TITLE>Onlisp:  Macros Returning Functions</TITLE>

<META NAME="description" CONTENT="Onlisp:  Macros Returning Functions">
<META NAME="keywords" CONTENT="Onlisp:  Macros Returning Functions">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

<LINK REL="contents" HREF="onlisp_toc.html#SEC_Contents">
<LINK REL="index" HREF="onlisp_31.html#SEC168">
<LINK REL="next" HREF="onlisp_17.html#SEC108">
<LINK REL="prev" HREF="onlisp_15.html#SEC99">

<META http-equiv="Content-Style-Type" content="text/css">
<link rel="StyleSheet" href="css/midnight.css" type="text/css" id="css1">
<script type="text/javascript" src="style1.js"></script>
<link rel="stylesheet" type="text/css" href="css/meadowmemo.css">

</HEAD>
<BODY LANG="ja" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<!--Infoseek Analyzer start-->
<script LANGUAGE="javascript">PgNo=20;</script>
<script src="http://js1.infoseek.co.jp/bin/57/00170.js"></script>
<noscript><a href="http://ax1.www.infoseek.co.jp/bin/go?0017057t" target="_blank">
<img src="http://ax1.www.infoseek.co.jp/bin/logo?0017057t" border=0></a></noscript>
<!--Infoseek Analyzer end-->
<a name="top"> </a>

<br><A NAME="SEC103"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_15.html#SEC102"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC104"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_15.html#SEC99"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Macros Returning Functions"></A>
<H1> 15. Macros Returning Functions </H1>
<!--docid::SEC103::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Macros+Returning+Functions">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Macros+Returning+Functions</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FMacrosReturningFunctions">comment</a>(none) to "onlisp/MacrosReturningFunctions"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

Chapter 5 showed how to write functions which return other functions. Macros
make the task of combining operators much easier. This chapter will show how to
use macros to build abstractions which are equivalent to those defined in Chapter 5,
but cleaner and more efficient.
<P>

<div class="menuindex"><SCRIPT language=JavaScript src="onlisp15.js"></SCRIPT></div><noscript><BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_16.html#SEC104">15.1 Building Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_16.html#SEC105">15.2 Recursion on Cdrs</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_16.html#SEC106">15.3 Recursion on Subtrees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_16.html#SEC107">15.4 Lazy Evaluation</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE></noscript>
<P>

<A NAME="Building Functions"></A>
<HR SIZE="6">
<br><A NAME="SEC104"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC105"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Building Functions"></A>
<H2> 15.1 Building Functions </H2>
<!--docid::SEC104::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Building+Functions">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Building+Functions</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FBuildingFunctions">comment</a>(none) to "onlisp/BuildingFunctions"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

If f and g are functions, then f #g(x) = f (g(x)). Section 5.4 showed how to
implement the # operator as a Lisp function called compose:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (funcall (compose #'list #'1+) 2)
(3)
</pre></td></tr></table><P>

In this section, we consider ways to define better function builders with macros.
Figure 15.1 contains a general function-builder called fn, which builds compound
functions from their descriptions. Its argument should be an expression of the
form (operator . arguments). The operator can be the name of a function or
macro--or compose, which is treated specially. The arguments can be names of
functions or macros of one argument, or expressions that could be arguments to
fn. For example,
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(fn (and integerp oddp))
</pre></td></tr></table><P>

yields a function equivalent to
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#'
(lambda (x) (and (integerp x) (oddp x)))
</pre></td></tr></table><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defmacro fn (expr) `#',(rbuild expr))

(defun rbuild (expr)
  (if (or (atom expr) (eq (car expr) 'lambda))
      expr
    (if (eq (car expr) 'compose)
	(build-compose (cdr expr))
      (build-call (car expr) (cdr expr)))))

(defun build-call (op fns)
  (let ((g (gensym)))
    `(lambda (,g)
       (,op ,&#64;(mapcar #'(lambda (f)
			   `(,(rbuild f) ,g))
		       fns)))))

(defun build-compose (fns)
  (let ((g (gensym)))
    `(lambda (,g)
       ,(labels ((rec (fns)
		      (if fns
			  `(,(rbuild (car fns))
			    ,(rec (cdr fns)))
			g)))
	  (rec fns)))))
</pre></td></tr></table><P>

<center>
 Figure 15.1: General function-building macro.
</center>
<A NAME="IDX77"></A>
<P>

If we use compose as the operator, we get a function representing the composition of the arguments, but without the explicit funcalls that were needed when
compose was defined as a function. For example,
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(fn (compose list 1+ truncate))
</pre></td></tr></table><P>

expands into:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#'
(lambda (#:g1) (list (1+ (truncate #:g1))))
</pre></td></tr></table><P>

which enables inline compilation of simple functions like list and 1+. The
fn macro takes names of operators in the general sense; lambda-expressions are
allowed too, as in
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(fn (compose (lambda (x) (+ x 3)) truncate))
</pre></td></tr></table><P>

which expands into
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#'
(lambda (#:g2) ((lambda (x) (+ x 3)) (truncate #:g2)))
</pre></td></tr></table><P>

Here the function expressed as a lambda-expression will certainly be compiled
inline, whereas a sharp-quoted lambda-expression given as an argument to the
function compose would have to be funcalled.
<P>

Section 5.4 showed how to define three more function builders: fif, fint,
and fun. These are now subsumed in the general fn macro. Using and as the
operator yields the intersection of the operators given as arguments:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (mapcar (fn (and integerp oddp))
'(c 3 p 0))
(NIL T NIL NIL)
</pre></td></tr></table><P>

while or yields the union:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (mapcar (fn (or integerp symbolp))
'(c 3 p 0.2))
(T T T NIL)
</pre></td></tr></table><P>

and if yields a function whose body is a conditional:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (map1-n (fn (if oddp 1+ identity)) 6)
(2 2 4 4 6 6)
</pre></td></tr></table><P>

However, we can use other Lisp functions besides these three:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (mapcar (fn (list 1- identity 1+))
'(1 2 3))
((0 1 2) (1 2 3) (2 3 4))
</pre></td></tr></table><P>

and the arguments in the fn expression may themselves be expressions:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (remove-if (fn (or (and integerp oddp)
(and consp cdr)))
'(1 (a b) c (d) 2 3.4 (e f g)))
(C (D) 2 3.4)
</pre></td></tr></table><P>

Making fn treat compose as a special case does not make it any more powerful.
If you nest the arguments to fn, you get functional composition. For example,
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(fn (list (1+ truncate)))
</pre></td></tr></table><P>

expands into:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#'
(lambda (#:g1)
    (list ((lambda (#:g2) (1+ (truncate #:g2))) #:g1)))
</pre></td></tr></table><P>

which behaves like
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(compose #'list #'1+ #'truncate)
</pre></td></tr></table><P>

The fn macro treats compose as a special case only to make such calls easier to
read.
<P>

<A NAME="Recursion on Cdrs (Macros Returning Functions)"></A>
<HR SIZE="6">
<br><A NAME="SEC105"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC104"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC106"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Recursion on Cdrs (Macros Returning Functions)"></A>
<H2> 15.2 Recursion on Cdrs </H2>
<!--docid::SEC105::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Recursion+on+Cdrs+%28Macros+Returning+Functions%29">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Recursion+on+Cdrs+%28Macros+Returning+Functions%29</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FRecursiononCdrs">comment</a>(none) to "onlisp/RecursiononCdrs"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

Sections 5.5 and 5.6 showed how to write functions that build recursive functions.
The following two sections show how anaphoric macros can provide a cleaner
interface to the functions we defined there.
<P>

Section 5.5 showed how to define a flat list recurser builder called lrec. With
lrec we can express a call to:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun our-every (fn lst)
  (if (null lst)
      t
    (and (funcall fn (car lst))
	 (our-every fn (cdr lst)))))
</pre></td></tr></table><P>

for e.g. oddp as:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lrec #'(lambda (x f) (and (oddp x) (funcall f)))
      t)
</pre></td></tr></table><P>

Here macros could make life easier. How much do we really have to say to
express recursive functions? If we can refer anaphorically to the current car of
the list (as it) and the recursive call (as rec), we should be able to make do with
something like:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(alrec (and (oddp it) rec) t)
</pre></td></tr></table><P>

Figure 15.2 contains the definition of the macro which will allow us to say this.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (funcall (alrec (and (oddp it) rec) t)
'(1 3 5))
T
</pre></td></tr></table><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defmacro alrec (rec &#38;optional base)
  "cltl2 version"
  (let ((gfn (gensym)))
    `(lrec #'(lambda (it ,gfn)
	       (symbol-macrolet ((rec (funcall ,gfn)))
		 ,rec))
	   ,base)))

(defmacro alrec (rec &#38;optional base)
  "cltl1 version"
  (let ((gfn (gensym)))
    `(lrec #'(lambda (it ,gfn)
	       (labels ((rec () (funcall ,gfn)))
		 ,rec))
	   ,base)))

(defmacro on-cdrs (rec base &#38;rest lsts)
  `(funcall (alrec ,rec #'(lambda () ,base)) ,&#64;lsts))
</pre></td></tr></table><P>

<center>
 Figure 15.2: Macros for list recursion.
</center>
<A NAME="IDX78"></A>
<P>

The new macro works by transforming the expression given as the second
argument into a function to be passed to lrec. Since the second argument may
refer anaphorically to it or rec, in the macro expansion the body of the function
must appear within the scope of bindings established for these symbols.
<P>

Figure 15.2 actually has two different versions of alrec. The version used
in the preceding examples requires symbol macros (Section 7.11). Only recent
versions of Common Lisp have symbol macros, so Figure 15.2 also contains
a slightly less convenient version of alrec in which rec is defined as a local
function. The price is that, as a function, rec would have to be enclosed within
parentheses:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(alrec (and (oddp it) (rec)) t)
</pre></td></tr></table><P>

The original version is preferable in Common Lisp implementations which provide
symbol-macrolet.
<P>

Common Lisp, with its separate name-space for functions, makes it awkward
to use these recursion builders to define named functions:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setf (symbol-function 'our-length)
      (alrec (1+ rec) 0))
</pre></td></tr></table><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun our-copy-list (lst)
  (on-cdrs (cons it rec) nil lst))

(defun our-remove-duplicates (lst)
  (on-cdrs (adjoin it rec) nil lst))

(defun our-find-if (fn lst)
  (on-cdrs (if (funcall fn it) it rec) nil lst))

(defun our-some (fn lst)
  (on-cdrs (or (funcall fn it) rec) nil lst))
</pre></td></tr></table><P>

<center>
 Figure 15.3: Common Lisp functions defined with on-cdrs.
</center>
<A NAME="IDX79"></A>
<P>

The final macro in Figure 15.2 is intended to make this more abstract. Using
on-cdrs we could say instead:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun our-length (lst)
  (on-cdrs (1+ rec) 0 lst))

(defun our-every (fn lst)
  (on-cdrs (and (funcall fn it) rec) t lst))
</pre></td></tr></table><P>

Figure 15.3 shows some existing Common Lisp functions defined with the
new macro. Expressed with on-cdrs, these functions are reduced to their most
basic form, and we notice similarities between them which might not otherwise
have been apparent.
<P>

Figure 15.4 contains some new utilities which can easily be defined with
on-cdrs. The first three, unions, intersections, and differences implement set union, intersection, and complement, respectively. Common Lisp has
built-in functions for these operations, but they can only take two lists at a time.
Thus if we want to find the union of three lists we have to say:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (union '(a b) (union '(b c) '(c d)))
(A B C D)
</pre></td></tr></table><P>

The new unions behaves like union, but takes an arbitrary number of arguments,
so that we could say:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (unions '(a b) '(b c) '(c d))
(D C A B)
</pre></td></tr></table><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun unions (&#38;rest sets)
  (on-cdrs (union it rec) (car sets) (cdr sets)))

(defun intersections (&#38;rest sets)
  (unless (some #'null sets)
    (on-cdrs (intersection it rec) (car sets) (cdr sets))))

(defun differences (set &#38;rest outs)
  (on-cdrs (set-difference rec it) set outs))

(defun maxmin (args)
  (when args
    (on-cdrs (multiple-value-bind (mx mn) rec
	       (values (max mx it) (min mn it)))
	     (values (car args) (car args))
	     (cdr args))))
</pre></td></tr></table><P>

<center>
 Figure 15.4: New utilities defined with on-cdrs.
</center>
<A NAME="IDX80"></A>
<P>

Like union, unions does not preserve the order of the elements in the initial lists.
<P>

The same relation holds between the Common Lisp intersection and the
more general intersections. In the definition of this function, the initial test
for null arguments was added for efficiency; it short-circuits the computation if
one of the sets is empty.
<P>

Common Lisp also has a function called set-difference, which takes two
lists and returns the elements of the first which are not in the second:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (set-difference '(a b c d) '(a c))
(D B)
</pre></td></tr></table><P>

Our new version handles multiple arguments much as - does. For example,
(differences x y z) is equivalent to (set-difference x (unions y z)),
though without the consing that the latter would entail.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (differences '(a b c d e) '(a f) '(d))
(B C E)
</pre></td></tr></table><P>

These set operators are intended only as examples. There is no real need for
them, because they represent a degenerate case of list recursion already handled
by the built-in reduce. For example, instead of
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(unions ...)
</pre></td></tr></table><P>

you might as well say just
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>((lambda (&#38;rest args) (reduce #'union args)) ...)
</pre></td></tr></table><P>

In the general case, on-cdrs is more powerful than reduce, however.
<P>

Because rec refers to a call instead of a value, we can use on-cdrs to create
functions which return multiple values. The final function in Figure 15.4, maxmin,
takes advantage of this possibility to find both the maximum and minimum elements in a single traversal of a list:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (maxmin '(3 4 2 8 5 1 6 7))
8
1
</pre></td></tr></table><P>

It would also have been possible to use on-cdrs in some of the code which
appears in later chapters. For example, compile-cmds (page 310)
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun compile-cmds (cmds)
  (if (null cmds)
      'regs
    `(,&#64;(car cmds) ,(compile-cmds (cdr cmds)))))
</pre></td></tr></table><P>

could have been defined as simply:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun compile-cmds (cmds)
  (on-cdrs `(,&#64;it ,rec) 'regs cmds))
</pre></td></tr></table><P>

<A NAME="Recursion on Subtrees (Macros Returning Functions)"></A>
<HR SIZE="6">
<br><A NAME="SEC106"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC105"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC107"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Recursion on Subtrees (Macros Returning Functions)"></A>
<H2> 15.3 Recursion on Subtrees </H2>
<!--docid::SEC106::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Recursion+on+Subtrees+%28Macros+Returning+Functions%29">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Recursion+on+Subtrees+%28Macros+Returning+Functions%29</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FRecursiononSubtrees">comment</a>(none) to "onlisp/RecursiononSubtrees"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

What macros did for recursion on lists, they can also do for recursion on trees.
In this section, we use macros to define cleaner interfaces to the tree recursers
defined in Section 5.6.
<P>

In Section 5.6 we defined two tree recursion builders, ttrav,which always traverses the whole tree, and trec which is more complex, but allows you to control
when recursion stops. Using these functions we could express our-copy-tree
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun our-copy-tree (tree)
  (if (atom tree)
      tree
    (cons (our-copy-tree (car tree))
	  (if (cdr tree) (our-copy-tree (cdr tree))))))
</pre></td></tr></table><P>

as
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(ttrav #'cons)
</pre></td></tr></table><P>

and a call to rfind-if
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun rfind-if (fn tree)
  (if (atom tree)
      (and (funcall fn tree) tree)
    (or (rfind-if fn (car tree))
	(and (cdr tree) (rfind-if fn (cdr tree))))))
</pre></td></tr></table><P>

for e.g. oddp as:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(trec #'(lambda (o l r) (or (funcall l) (funcall r)))
      #'(lambda (tree) (and (oddp tree) tree)))
</pre></td></tr></table><P>

Anaphoric macros can make a better interface to trec, as they did for lrec in
the previous section. A macro sufficient for the general case will have to be able
to refer anaphorically to three things: the current tree, which we'll call it, the
recursion down the left subtree, which we'll call left, and the recursion down
the right subtree, which we'll call right. With these conventions established, we
should be able to express the preceding functions in terms of a new macro thus:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(atrec (cons left right))

(atrec (or left right) (and (oddp it) it))
</pre></td></tr></table><P>

Figure 15.5 contains the definition of this macro.
<P>

In versions of Lisp which don't have symbol-macrolet,we can define atrec
using the second definition in Figure 15.5. This version defines left and right
as local functions, so our-copy-tree would have to be expressed as:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(atrec (cons (left) (right)))
</pre></td></tr></table><P>

For convenience, we also define a macro on-trees, which is analogous to
on-cdrs from the previous section. Figure 15.6 shows the four functions from
Section 5.6 defined with on-trees.
<P>

As noted in Chapter 5, functions built by the recurser generators defined in
that chapter will not be tail-recursive. Using on-cdrs or on-trees to define a
function will not necessarily yield the most efficient implementation. Like the
underlying trec and lrec, these macros are mainly for use in prototypes and in
parts of a program where efficiency is not paramount. However, the underlying
idea of this chapter and Chapter 5 is that one can write function generators and
put a clean macro interface on them. This same technique could equally well be
used to build function generators which yielded particularly efficient code.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defmacro atrec (rec &#38;optional (base 'it))
  "cltl2 version"
  (let ((lfn (gensym)) (rfn (gensym)))
    `(trec #'(lambda (it ,lfn ,rfn)
	       (symbol-macrolet ((left (funcall ,lfn))
				 (right (funcall ,rfn)))
		 ,rec))
	   #'(lambda (it) ,base))))

(defmacro atrec (rec &#38;optional (base 'it))
  "cltl1 version"
  (let ((lfn (gensym)) (rfn (gensym)))
    `(trec #'(lambda (it ,lfn ,rfn)
	       (labels ((left () (funcall ,lfn))
			(right () (funcall ,rfn)))
		 ,rec))
	   #'(lambda (it) ,base))))

(defmacro on-trees (rec base &#38;rest trees)
  `(funcall (atrec ,rec ,base) ,&#64;trees))
</pre></td></tr></table><P>

<center>
 Figure 15.5: Macros for recursion on trees.
</center>
<A NAME="IDX81"></A>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun our-copy-tree (tree)
  (on-trees (cons left right) it tree))

(defun count-leaves (tree)
  (on-trees (+ left (or right 1)) 1 tree))

(defun flatten (tree)
  (on-trees (nconc left right) (mklist it) tree))

(defun rfind-if (fn tree)
  (on-trees (or left right)
	    (and (funcall fn it) it)
	    tree))
</pre></td></tr></table><P>

<center>
 Figure 15.6: Functions defined using on-trees.
</center>
<A NAME="IDX82"></A>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconstant unforced (gensym))

(defstruct delay forced closure)

(defmacro delay (expr)
  (let ((self (gensym)))
    `(let ((,self (make-delay :forced unforced)))
       (setf (delay-closure ,self)
	     #'(lambda ()
		 (setf (delay-forced ,self) ,expr)))
       ,self)))

(defun force (x)
  (if (delay-p x)
      (if (eq (delay-forced x) unforced)
	  (funcall (delay-closure x))
	(delay-forced x))
    x))
</pre></td></tr></table><P>

<center>
 Figure 15.7: Implementation of force and delay.
</center>
<A NAME="IDX83"></A>
<P>

<A NAME="Lazy Evaluation"></A>
<HR SIZE="6">
<br><A NAME="SEC107"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC106"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Lazy Evaluation"></A>
<H2> 15.4 Lazy Evaluation </H2>
<!--docid::SEC107::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Lazy+Evaluation">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Lazy+Evaluation</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FLazyEvaluation">comment</a>(none) to "onlisp/LazyEvaluation"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

Lazy evaluation means only evaluating an expression when you need its value.
One way to use lazy evaluation is to build an object known as a delay. A delay is
a placeholder for the value of some expression. It represents a promise to deliver
the value of the expression if it is needed at some later time. Meanwhile, since
the promise is a Lisp object, it can serve many of the purposes of the value it
represents. And when the value of the expression is needed, the delay can return
it.
<P>

Scheme has built-in support for delays. The Scheme operators force and
delay can be implemented in Common Lisp as in Figure 15.7. A delay is
represented as a two-part structure. The first field indicates whether the delay has
been evaluated yet, and if it has, contains the value. The second field contains a
closure which can be called to find the value that the delay represents. The macro
delay takes an expression, and returns a delay representing its value:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (let ((x 2))
(setq d (delay (1+ x))))
#S(DELAY ...)
</pre></td></tr></table><P>

To call the closure within a delay is to force the delay. The function force
takes any object: for ordinary objects it is the identity function, but for delays it
is a demand for the value that the delay represents.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (force 'a)
A
&#62; (force d)
3
</pre></td></tr></table><P>

We use force whenever we are dealing with objects that might be delays. For
example, if we are sorting a list which might contain delays, we would say:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(sort lst #'(lambda (x y) (&#62; (force x) (force y))))
</pre></td></tr></table><P>

It's slightly inconvenient to use delays in this naked form. In a real application,
they might be hidden beneath another layer of abstraction.
<P>

<A NAME="Macro-Defining Macros"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_16.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_17.html#SEC108"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<a name="bottom"> </a>
<script type="text/javascript" src="style2.js"></script>
<div class="footer">
    <br>
mail:<img src="http://www.bookshelf.jp/img/mail.jpg"><br>

<br>
<script src="http://trackfeed.com/usr/2d246b4e25.js"></script>
</div>

</BODY>

</HTML>
